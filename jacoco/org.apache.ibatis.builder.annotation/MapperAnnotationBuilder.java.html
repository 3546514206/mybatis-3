<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapperAnnotationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis</a> &gt; <a href="index.source.html" class="el_package">org.apache.ibatis.builder.annotation</a> &gt; <span class="el_source">MapperAnnotationBuilder.java</span></div><h1>MapperAnnotationBuilder.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2009-2023 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.builder.annotation;

import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.ibatis.annotations.Arg;
import org.apache.ibatis.annotations.CacheNamespace;
import org.apache.ibatis.annotations.CacheNamespaceRef;
import org.apache.ibatis.annotations.Case;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.DeleteProvider;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.InsertProvider;
import org.apache.ibatis.annotations.Lang;
import org.apache.ibatis.annotations.MapKey;
import org.apache.ibatis.annotations.Options;
import org.apache.ibatis.annotations.Options.FlushCachePolicy;
import org.apache.ibatis.annotations.Property;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.ResultMap;
import org.apache.ibatis.annotations.ResultType;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.SelectKey;
import org.apache.ibatis.annotations.SelectProvider;
import org.apache.ibatis.annotations.TypeDiscriminator;
import org.apache.ibatis.annotations.Update;
import org.apache.ibatis.annotations.UpdateProvider;
import org.apache.ibatis.binding.MapperMethod.ParamMap;
import org.apache.ibatis.builder.BuilderException;
import org.apache.ibatis.builder.CacheRefResolver;
import org.apache.ibatis.builder.IncompleteElementException;
import org.apache.ibatis.builder.MapperBuilderAssistant;
import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.cursor.Cursor;
import org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator;
import org.apache.ibatis.executor.keygen.KeyGenerator;
import org.apache.ibatis.executor.keygen.NoKeyGenerator;
import org.apache.ibatis.executor.keygen.SelectKeyGenerator;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.mapping.Discriminator;
import org.apache.ibatis.mapping.FetchType;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ResultFlag;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.mapping.ResultSetType;
import org.apache.ibatis.mapping.SqlCommandType;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.mapping.StatementType;
import org.apache.ibatis.parsing.PropertyParser;
import org.apache.ibatis.reflection.TypeParameterResolver;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.UnknownTypeHandler;

/**
 * @author Clinton Begin
 * @author Kazuki Shimizu
 */
public class MapperAnnotationBuilder {

<span class="fc" id="L99">  private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; statementAnnotationTypes = Stream</span>
<span class="fc" id="L100">      .of(Select.class, Update.class, Insert.class, Delete.class, SelectProvider.class, UpdateProvider.class,</span>
          InsertProvider.class, DeleteProvider.class)
<span class="fc" id="L102">      .collect(Collectors.toSet());</span>

  private final Configuration configuration;
  private final MapperBuilderAssistant assistant;
  private final Class&lt;?&gt; type;

<span class="fc" id="L108">  public MapperAnnotationBuilder(Configuration configuration, Class&lt;?&gt; type) {</span>
<span class="fc" id="L109">    String resource = type.getName().replace('.', '/') + &quot;.java (best guess)&quot;;</span>
<span class="fc" id="L110">    this.assistant = new MapperBuilderAssistant(configuration, resource);</span>
<span class="fc" id="L111">    this.configuration = configuration;</span>
<span class="fc" id="L112">    this.type = type;</span>
<span class="fc" id="L113">  }</span>

  public void parse() {
<span class="fc" id="L116">    String resource = type.toString();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">    if (!configuration.isResourceLoaded(resource)) {</span>
<span class="fc" id="L118">      loadXmlResource();</span>
<span class="fc" id="L119">      configuration.addLoadedResource(resource);</span>
<span class="fc" id="L120">      assistant.setCurrentNamespace(type.getName());</span>
<span class="fc" id="L121">      parseCache();</span>
<span class="fc" id="L122">      parseCacheRef();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">      for (Method method : type.getMethods()) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (!canHaveStatement(method)) {</span>
<span class="fc" id="L125">          continue;</span>
        }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (getAnnotationWrapper(method, false, Select.class, SelectProvider.class).isPresent()</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            &amp;&amp; method.getAnnotation(ResultMap.class) == null) {</span>
<span class="fc" id="L129">          parseResultMap(method);</span>
        }
        try {
<span class="fc" id="L132">          parseStatement(method);</span>
<span class="fc" id="L133">        } catch (IncompleteElementException e) {</span>
<span class="fc" id="L134">          configuration.addIncompleteMethod(new MethodResolver(this, method));</span>
<span class="fc" id="L135">        }</span>
      }
    }
<span class="fc" id="L138">    parsePendingMethods();</span>
<span class="fc" id="L139">  }</span>

  private static boolean canHaveStatement(Method method) {
    // issue #237
<span class="fc bfc" id="L143" title="All 4 branches covered.">    return !method.isBridge() &amp;&amp; !method.isDefault();</span>
  }

  private void parsePendingMethods() {
<span class="fc" id="L147">    Collection&lt;MethodResolver&gt; incompleteMethods = configuration.getIncompleteMethods();</span>
<span class="fc" id="L148">    synchronized (incompleteMethods) {</span>
<span class="fc" id="L149">      Iterator&lt;MethodResolver&gt; iter = incompleteMethods.iterator();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      while (iter.hasNext()) {</span>
        try {
<span class="fc" id="L152">          iter.next().resolve();</span>
<span class="fc" id="L153">          iter.remove();</span>
<span class="fc" id="L154">        } catch (IncompleteElementException e) {</span>
          // This method is still missing a resource
<span class="fc" id="L156">        }</span>
      }
<span class="fc" id="L158">    }</span>
<span class="fc" id="L159">  }</span>

  private void loadXmlResource() {
    // Spring may not know the real resource name so we check a flag
    // to prevent loading again a resource twice
    // this flag is set at XMLMapperBuilder#bindMapperForNamespace
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) {</span>
<span class="fc" id="L166">      String xmlResource = type.getName().replace('.', '/') + &quot;.xml&quot;;</span>
      // #1347
<span class="fc" id="L168">      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (inputStream == null) {</span>
        // Search XML mapper that is not in the module but in the classpath.
        try {
<span class="nc" id="L172">          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span>
<span class="fc" id="L173">        } catch (IOException e2) {</span>
          // ignore, resource is not required
<span class="nc" id="L175">        }</span>
      }
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (inputStream != null) {</span>
<span class="fc" id="L178">        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource,</span>
<span class="fc" id="L179">            configuration.getSqlFragments(), type.getName());</span>
<span class="fc" id="L180">        xmlParser.parse();</span>
      }
    }
<span class="fc" id="L183">  }</span>

  private void parseCache() {
<span class="fc" id="L186">    CacheNamespace cacheDomain = type.getAnnotation(CacheNamespace.class);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (cacheDomain != null) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">      Integer size = cacheDomain.size() == 0 ? null : cacheDomain.size();</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">      Long flushInterval = cacheDomain.flushInterval() == 0 ? null : cacheDomain.flushInterval();</span>
<span class="fc" id="L190">      Properties props = convertToProperties(cacheDomain.properties());</span>
<span class="fc" id="L191">      assistant.useNewCache(cacheDomain.implementation(), cacheDomain.eviction(), flushInterval, size,</span>
<span class="fc" id="L192">          cacheDomain.readWrite(), cacheDomain.blocking(), props);</span>
    }
<span class="fc" id="L194">  }</span>

  private Properties convertToProperties(Property[] properties) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (properties.length == 0) {</span>
<span class="fc" id="L198">      return null;</span>
    }
<span class="fc" id="L200">    Properties props = new Properties();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    for (Property property : properties) {</span>
<span class="fc" id="L202">      props.setProperty(property.name(), PropertyParser.parse(property.value(), configuration.getVariables()));</span>
    }
<span class="fc" id="L204">    return props;</span>
  }

  private void parseCacheRef() {
<span class="fc" id="L208">    CacheNamespaceRef cacheDomainRef = type.getAnnotation(CacheNamespaceRef.class);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    if (cacheDomainRef != null) {</span>
<span class="fc" id="L210">      Class&lt;?&gt; refType = cacheDomainRef.value();</span>
<span class="fc" id="L211">      String refName = cacheDomainRef.name();</span>
<span class="fc bfc" id="L212" title="All 4 branches covered.">      if (refType == void.class &amp;&amp; refName.isEmpty()) {</span>
<span class="fc" id="L213">        throw new BuilderException(&quot;Should be specified either value() or name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L215" title="All 4 branches covered.">      if (refType != void.class &amp;&amp; !refName.isEmpty()) {</span>
<span class="fc" id="L216">        throw new BuilderException(&quot;Cannot use both value() and name() attribute in the @CacheNamespaceRef&quot;);</span>
      }
<span class="fc bfc" id="L218" title="All 2 branches covered.">      String namespace = refType != void.class ? refType.getName() : refName;</span>
      try {
<span class="fc" id="L220">        assistant.useCacheRef(namespace);</span>
<span class="fc" id="L221">      } catch (IncompleteElementException e) {</span>
<span class="fc" id="L222">        configuration.addIncompleteCacheRef(new CacheRefResolver(assistant, namespace));</span>
<span class="fc" id="L223">      }</span>
    }
<span class="fc" id="L225">  }</span>

  private String parseResultMap(Method method) {
<span class="fc" id="L228">    Class&lt;?&gt; returnType = getReturnType(method, type);</span>
<span class="fc" id="L229">    Arg[] args = method.getAnnotationsByType(Arg.class);</span>
<span class="fc" id="L230">    Result[] results = method.getAnnotationsByType(Result.class);</span>
<span class="fc" id="L231">    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);</span>
<span class="fc" id="L232">    String resultMapId = generateResultMapName(method);</span>
<span class="fc" id="L233">    applyResultMap(resultMapId, returnType, args, results, typeDiscriminator);</span>
<span class="fc" id="L234">    return resultMapId;</span>
  }

  private String generateResultMapName(Method method) {
<span class="fc" id="L238">    Results results = method.getAnnotation(Results.class);</span>
<span class="fc bfc" id="L239" title="All 4 branches covered.">    if (results != null &amp;&amp; !results.id().isEmpty()) {</span>
<span class="fc" id="L240">      return type.getName() + &quot;.&quot; + results.id();</span>
    }
<span class="fc" id="L242">    StringBuilder suffix = new StringBuilder();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    for (Class&lt;?&gt; c : method.getParameterTypes()) {</span>
<span class="fc" id="L244">      suffix.append(&quot;-&quot;);</span>
<span class="fc" id="L245">      suffix.append(c.getSimpleName());</span>
    }
<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (suffix.length() &lt; 1) {</span>
<span class="fc" id="L248">      suffix.append(&quot;-void&quot;);</span>
    }
<span class="fc" id="L250">    return type.getName() + &quot;.&quot; + method.getName() + suffix;</span>
  }

  private void applyResultMap(String resultMapId, Class&lt;?&gt; returnType, Arg[] args, Result[] results,
      TypeDiscriminator discriminator) {
<span class="fc" id="L255">    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L256">    applyConstructorArgs(args, returnType, resultMappings);</span>
<span class="fc" id="L257">    applyResults(results, returnType, resultMappings);</span>
<span class="fc" id="L258">    Discriminator disc = applyDiscriminator(resultMapId, returnType, discriminator);</span>
    // TODO add AutoMappingBehaviour
<span class="fc" id="L260">    assistant.addResultMap(resultMapId, returnType, null, disc, resultMappings, null);</span>
<span class="fc" id="L261">    createDiscriminatorResultMaps(resultMapId, returnType, discriminator);</span>
<span class="fc" id="L262">  }</span>

  private void createDiscriminatorResultMaps(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">      for (Case c : discriminator.cases()) {</span>
<span class="fc" id="L267">        String caseResultMapId = resultMapId + &quot;-&quot; + c.value();</span>
<span class="fc" id="L268">        List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();</span>
        // issue #136
<span class="fc" id="L270">        applyConstructorArgs(c.constructArgs(), resultType, resultMappings);</span>
<span class="fc" id="L271">        applyResults(c.results(), resultType, resultMappings);</span>
        // TODO add AutoMappingBehaviour
<span class="fc" id="L273">        assistant.addResultMap(caseResultMapId, c.type(), resultMapId, null, resultMappings, null);</span>
      }
    }
<span class="fc" id="L276">  }</span>

  private Discriminator applyDiscriminator(String resultMapId, Class&lt;?&gt; resultType, TypeDiscriminator discriminator) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc" id="L280">      String column = discriminator.column();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">      Class&lt;?&gt; javaType = discriminator.javaType() == void.class ? String.class : discriminator.javaType();</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">      JdbcType jdbcType = discriminator.jdbcType() == JdbcType.UNDEFINED ? null : discriminator.jdbcType();</span>
      @SuppressWarnings(&quot;unchecked&quot;)
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) (discriminator
<span class="fc bfc" id="L285" title="All 2 branches covered.">          .typeHandler() == UnknownTypeHandler.class ? null : discriminator.typeHandler());</span>
<span class="fc" id="L286">      Case[] cases = discriminator.cases();</span>
<span class="fc" id="L287">      Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">      for (Case c : cases) {</span>
<span class="fc" id="L289">        String value = c.value();</span>
<span class="fc" id="L290">        String caseResultMapId = resultMapId + &quot;-&quot; + value;</span>
<span class="fc" id="L291">        discriminatorMap.put(value, caseResultMapId);</span>
      }
<span class="fc" id="L293">      return assistant.buildDiscriminator(resultType, column, javaType, jdbcType, typeHandler, discriminatorMap);</span>
    }
<span class="fc" id="L295">    return null;</span>
  }

  void parseStatement(Method method) {
<span class="fc" id="L299">    final Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span>
<span class="fc" id="L300">    final LanguageDriver languageDriver = getLanguageDriver(method);</span>

<span class="fc" id="L302">    getAnnotationWrapper(method, true, statementAnnotationTypes).ifPresent(statementAnnotation -&gt; {</span>
<span class="fc" id="L303">      final SqlSource sqlSource = buildSqlSource(statementAnnotation.getAnnotation(), parameterTypeClass,</span>
          languageDriver, method);
<span class="fc" id="L305">      final SqlCommandType sqlCommandType = statementAnnotation.getSqlCommandType();</span>
<span class="fc" id="L306">      final Options options = getAnnotationWrapper(method, false, Options.class).map(x -&gt; (Options) x.getAnnotation())</span>
<span class="fc" id="L307">          .orElse(null);</span>
<span class="fc" id="L308">      final String mappedStatementId = type.getName() + &quot;.&quot; + method.getName();</span>

      final KeyGenerator keyGenerator;
<span class="fc" id="L311">      String keyProperty = null;</span>
<span class="fc" id="L312">      String keyColumn = null;</span>
<span class="fc bfc" id="L313" title="All 4 branches covered.">      if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {</span>
        // first check for SelectKey annotation - that overrides everything else
<span class="fc" id="L315">        SelectKey selectKey = getAnnotationWrapper(method, false, SelectKey.class)</span>
<span class="fc" id="L316">            .map(x -&gt; (SelectKey) x.getAnnotation()).orElse(null);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (selectKey != null) {</span>
<span class="fc" id="L318">          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method),</span>
              languageDriver);
<span class="fc" id="L320">          keyProperty = selectKey.keyProperty();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        } else if (options == null) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
        } else {
<span class="fc bfc" id="L324" title="All 2 branches covered.">          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L325">          keyProperty = options.keyProperty();</span>
<span class="fc" id="L326">          keyColumn = options.keyColumn();</span>
        }
<span class="fc" id="L328">      } else {</span>
<span class="fc" id="L329">        keyGenerator = NoKeyGenerator.INSTANCE;</span>
      }

<span class="fc" id="L332">      Integer fetchSize = null;</span>
<span class="fc" id="L333">      Integer timeout = null;</span>
<span class="fc" id="L334">      StatementType statementType = StatementType.PREPARED;</span>
<span class="fc" id="L335">      ResultSetType resultSetType = configuration.getDefaultResultSetType();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">      boolean isSelect = sqlCommandType == SqlCommandType.SELECT;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">      boolean flushCache = !isSelect;</span>
<span class="fc" id="L338">      boolean useCache = isSelect;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">      if (options != null) {</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (FlushCachePolicy.TRUE.equals(options.flushCache())) {</span>
<span class="fc" id="L341">          flushCache = true;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {</span>
<span class="fc" id="L343">          flushCache = false;</span>
        }
<span class="fc" id="L345">        useCache = options.useCache();</span>
        // issue #348
<span class="fc bfc" id="L347" title="All 4 branches covered.">        fetchSize = options.fetchSize() &gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        timeout = options.timeout() &gt; -1 ? options.timeout() : null;</span>
<span class="fc" id="L349">        statementType = options.statementType();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (options.resultSetType() != ResultSetType.DEFAULT) {</span>
<span class="fc" id="L351">          resultSetType = options.resultSetType();</span>
        }
      }

<span class="fc" id="L355">      String resultMapId = null;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">      if (isSelect) {</span>
<span class="fc" id="L357">        ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (resultMapAnnotation != null) {</span>
<span class="fc" id="L359">          resultMapId = String.join(&quot;,&quot;, resultMapAnnotation.value());</span>
        } else {
<span class="fc" id="L361">          resultMapId = generateResultMapName(method);</span>
        }
      }

<span class="fc" id="L365">      assistant.addMappedStatement(mappedStatementId, sqlSource, statementType, sqlCommandType, fetchSize, timeout,</span>
          // ParameterMapID
<span class="fc" id="L367">          null, parameterTypeClass, resultMapId, getReturnType(method, type), resultSetType, flushCache, useCache,</span>
          // TODO gcode issue #577
<span class="fc" id="L369">          false, keyGenerator, keyProperty, keyColumn, statementAnnotation.getDatabaseId(), languageDriver,</span>
          // ResultSets
<span class="fc bfc" id="L371" title="All 2 branches covered.">          options != null ? nullOrEmpty(options.resultSets()) : null, statementAnnotation.isDirtySelect());</span>
<span class="fc" id="L372">    });</span>
<span class="fc" id="L373">  }</span>

  private LanguageDriver getLanguageDriver(Method method) {
<span class="fc" id="L376">    Lang lang = method.getAnnotation(Lang.class);</span>
<span class="fc" id="L377">    Class&lt;? extends LanguageDriver&gt; langClass = null;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (lang != null) {</span>
<span class="fc" id="L379">      langClass = lang.value();</span>
    }
<span class="fc" id="L381">    return configuration.getLanguageDriver(langClass);</span>
  }

  private Class&lt;?&gt; getParameterType(Method method) {
<span class="fc" id="L385">    Class&lt;?&gt; parameterType = null;</span>
<span class="fc" id="L386">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    for (Class&lt;?&gt; currentParameterType : parameterTypes) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">      if (!RowBounds.class.isAssignableFrom(currentParameterType)</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">          &amp;&amp; !ResultHandler.class.isAssignableFrom(currentParameterType)) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (parameterType == null) {</span>
<span class="fc" id="L391">          parameterType = currentParameterType;</span>
        } else {
          // issue #135
<span class="fc" id="L394">          parameterType = ParamMap.class;</span>
        }
      }
    }
<span class="fc" id="L398">    return parameterType;</span>
  }

  private static Class&lt;?&gt; getReturnType(Method method, Class&lt;?&gt; type) {
<span class="fc" id="L402">    Class&lt;?&gt; returnType = method.getReturnType();</span>
<span class="fc" id="L403">    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, type);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">    if (resolvedReturnType instanceof Class) {</span>
<span class="fc" id="L405">      returnType = (Class&lt;?&gt;) resolvedReturnType;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">      if (returnType.isArray()) {</span>
<span class="fc" id="L407">        returnType = returnType.getComponentType();</span>
      }
      // gcode issue #508
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (void.class.equals(returnType)) {</span>
<span class="fc" id="L411">        ResultType rt = method.getAnnotation(ResultType.class);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (rt != null) {</span>
<span class="fc" id="L413">          returnType = rt.value();</span>
        }
<span class="fc" id="L415">      }</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">    } else if (resolvedReturnType instanceof ParameterizedType) {</span>
<span class="fc" id="L417">      ParameterizedType parameterizedType = (ParameterizedType) resolvedReturnType;</span>
<span class="fc" id="L418">      Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span>
<span class="fc bfc" id="L419" title="All 4 branches covered.">      if (Collection.class.isAssignableFrom(rawType) || Cursor.class.isAssignableFrom(rawType)) {</span>
<span class="fc" id="L420">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L421" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 1) {</span>
<span class="fc" id="L422">          Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L424">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue #443) actual type can be a also a parameterized type
<span class="fc" id="L427">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">          } else if (returnTypeParameter instanceof GenericArrayType) {</span>
<span class="nc" id="L429">            Class&lt;?&gt; componentType = (Class&lt;?&gt;) ((GenericArrayType) returnTypeParameter).getGenericComponentType();</span>
            // (gcode issue #525) support List&lt;byte[]&gt;
<span class="nc" id="L431">            returnType = Array.newInstance(componentType, 0).getClass();</span>
          }
        }
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">      } else if (method.isAnnotationPresent(MapKey.class) &amp;&amp; Map.class.isAssignableFrom(rawType)) {</span>
        // (gcode issue 504) Do not look into Maps if there is not MapKey annotation
<span class="fc" id="L436">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="pc bpc" id="L437" title="2 of 4 branches missed.">        if (actualTypeArguments != null &amp;&amp; actualTypeArguments.length == 2) {</span>
<span class="fc" id="L438">          Type returnTypeParameter = actualTypeArguments[1];</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">          if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L440">            returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">          } else if (returnTypeParameter instanceof ParameterizedType) {</span>
            // (gcode issue 443) actual type can be a also a parameterized type
<span class="fc" id="L443">            returnType = (Class&lt;?&gt;) ((ParameterizedType) returnTypeParameter).getRawType();</span>
          }
        }
<span class="fc bfc" id="L446" title="All 2 branches covered.">      } else if (Optional.class.equals(rawType)) {</span>
<span class="fc" id="L447">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L448">        Type returnTypeParameter = actualTypeArguments[0];</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (returnTypeParameter instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L450">          returnType = (Class&lt;?&gt;) returnTypeParameter;</span>
        }
      }
    }

<span class="fc" id="L455">    return returnType;</span>
  }

  private void applyResults(Result[] results, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L459" title="All 2 branches covered.">    for (Result result : results) {</span>
<span class="fc" id="L460">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">      if (result.id()) {</span>
<span class="fc" id="L462">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) (result
<span class="fc bfc" id="L466" title="All 2 branches covered.">          .typeHandler() == UnknownTypeHandler.class ? null : result.typeHandler());</span>
<span class="fc" id="L467">      boolean hasNestedResultMap = hasNestedResultMap(result);</span>
<span class="fc" id="L468">      ResultMapping resultMapping = assistant.buildResultMapping(resultType, nullOrEmpty(result.property()),</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">          nullOrEmpty(result.column()), result.javaType() == void.class ? null : result.javaType(),</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">          result.jdbcType() == JdbcType.UNDEFINED ? null : result.jdbcType(),</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">          hasNestedSelect(result) ? nestedSelectId(result) : null,</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">          hasNestedResultMap ? nestedResultMapId(result) : null, null,</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">          hasNestedResultMap ? findColumnPrefix(result) : null, typeHandler, flags, null, null, isLazy(result));</span>
<span class="fc" id="L474">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L476">  }</span>

  private String findColumnPrefix(Result result) {
<span class="fc" id="L479">    String columnPrefix = result.one().columnPrefix();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (columnPrefix.length() &lt; 1) {</span>
<span class="fc" id="L481">      columnPrefix = result.many().columnPrefix();</span>
    }
<span class="fc" id="L483">    return columnPrefix;</span>
  }

  private String nestedResultMapId(Result result) {
<span class="fc" id="L487">    String resultMapId = result.one().resultMap();</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">    if (resultMapId.length() &lt; 1) {</span>
<span class="fc" id="L489">      resultMapId = result.many().resultMap();</span>
    }
<span class="fc bfc" id="L491" title="All 2 branches covered.">    if (!resultMapId.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L492">      resultMapId = type.getName() + &quot;.&quot; + resultMapId;</span>
    }
<span class="fc" id="L494">    return resultMapId;</span>
  }

  private boolean hasNestedResultMap(Result result) {
<span class="pc bpc" id="L498" title="1 of 4 branches missed.">    if (result.one().resultMap().length() &gt; 0 &amp;&amp; result.many().resultMap().length() &gt; 0) {</span>
<span class="nc" id="L499">      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</span>
    }
<span class="fc bfc" id="L501" title="All 4 branches covered.">    return result.one().resultMap().length() &gt; 0 || result.many().resultMap().length() &gt; 0;</span>
  }

  private String nestedSelectId(Result result) {
<span class="fc" id="L505">    String nestedSelect = result.one().select();</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">    if (nestedSelect.length() &lt; 1) {</span>
<span class="fc" id="L507">      nestedSelect = result.many().select();</span>
    }
<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (!nestedSelect.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L510">      nestedSelect = type.getName() + &quot;.&quot; + nestedSelect;</span>
    }
<span class="fc" id="L512">    return nestedSelect;</span>
  }

  private boolean isLazy(Result result) {
<span class="fc" id="L516">    boolean isLazy = configuration.isLazyLoadingEnabled();</span>
<span class="fc bfc" id="L517" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.one().fetchType()) {</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">      isLazy = result.one().fetchType() == FetchType.LAZY;</span>
<span class="fc bfc" id="L519" title="All 4 branches covered.">    } else if (result.many().select().length() &gt; 0 &amp;&amp; FetchType.DEFAULT != result.many().fetchType()) {</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">      isLazy = result.many().fetchType() == FetchType.LAZY;</span>
    }
<span class="fc" id="L522">    return isLazy;</span>
  }

  private boolean hasNestedSelect(Result result) {
<span class="fc bfc" id="L526" title="All 4 branches covered.">    if (result.one().select().length() &gt; 0 &amp;&amp; result.many().select().length() &gt; 0) {</span>
<span class="fc" id="L527">      throw new BuilderException(&quot;Cannot use both @One and @Many annotations in the same @Result&quot;);</span>
    }
<span class="fc bfc" id="L529" title="All 4 branches covered.">    return result.one().select().length() &gt; 0 || result.many().select().length() &gt; 0;</span>
  }

  private void applyConstructorArgs(Arg[] args, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) {
<span class="fc bfc" id="L533" title="All 2 branches covered.">    for (Arg arg : args) {</span>
<span class="fc" id="L534">      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L535">      flags.add(ResultFlag.CONSTRUCTOR);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">      if (arg.id()) {</span>
<span class="fc" id="L537">        flags.add(ResultFlag.ID);</span>
      }
      @SuppressWarnings(&quot;unchecked&quot;)
      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) (arg
<span class="fc bfc" id="L541" title="All 2 branches covered.">          .typeHandler() == UnknownTypeHandler.class ? null : arg.typeHandler());</span>
<span class="fc" id="L542">      ResultMapping resultMapping = assistant.buildResultMapping(resultType, nullOrEmpty(arg.name()),</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">          nullOrEmpty(arg.column()), arg.javaType() == void.class ? null : arg.javaType(),</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">          arg.jdbcType() == JdbcType.UNDEFINED ? null : arg.jdbcType(), nullOrEmpty(arg.select()),</span>
<span class="fc" id="L545">          nullOrEmpty(arg.resultMap()), null, nullOrEmpty(arg.columnPrefix()), typeHandler, flags, null, null, false);</span>
<span class="fc" id="L546">      resultMappings.add(resultMapping);</span>
    }
<span class="fc" id="L548">  }</span>

  private String nullOrEmpty(String value) {
<span class="pc bpc" id="L551" title="1 of 4 branches missed.">    return value == null || value.trim().length() == 0 ? null : value;</span>
  }

  private KeyGenerator handleSelectKeyAnnotation(SelectKey selectKeyAnnotation, String baseStatementId,
      Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver) {
<span class="fc" id="L556">    String id = baseStatementId + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span>
<span class="fc" id="L557">    Class&lt;?&gt; resultTypeClass = selectKeyAnnotation.resultType();</span>
<span class="fc" id="L558">    StatementType statementType = selectKeyAnnotation.statementType();</span>
<span class="fc" id="L559">    String keyProperty = selectKeyAnnotation.keyProperty();</span>
<span class="fc" id="L560">    String keyColumn = selectKeyAnnotation.keyColumn();</span>
<span class="fc" id="L561">    boolean executeBefore = selectKeyAnnotation.before();</span>

    // defaults
<span class="fc" id="L564">    boolean useCache = false;</span>
<span class="fc" id="L565">    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;</span>
<span class="fc" id="L566">    Integer fetchSize = null;</span>
<span class="fc" id="L567">    Integer timeout = null;</span>
<span class="fc" id="L568">    boolean flushCache = false;</span>
<span class="fc" id="L569">    String parameterMap = null;</span>
<span class="fc" id="L570">    String resultMap = null;</span>
<span class="fc" id="L571">    ResultSetType resultSetTypeEnum = null;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    String databaseId = selectKeyAnnotation.databaseId().isEmpty() ? null : selectKeyAnnotation.databaseId();</span>

<span class="fc" id="L574">    SqlSource sqlSource = buildSqlSource(selectKeyAnnotation, parameterTypeClass, languageDriver, null);</span>
<span class="fc" id="L575">    SqlCommandType sqlCommandType = SqlCommandType.SELECT;</span>

<span class="fc" id="L577">    assistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap,</span>
        parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, false, keyGenerator,
        keyProperty, keyColumn, databaseId, languageDriver, null, false);

<span class="fc" id="L581">    id = assistant.applyCurrentNamespace(id, false);</span>

<span class="fc" id="L583">    MappedStatement keyStatement = configuration.getMappedStatement(id, false);</span>
<span class="fc" id="L584">    SelectKeyGenerator answer = new SelectKeyGenerator(keyStatement, executeBefore);</span>
<span class="fc" id="L585">    configuration.addKeyGenerator(id, answer);</span>
<span class="fc" id="L586">    return answer;</span>
  }

  private SqlSource buildSqlSource(Annotation annotation, Class&lt;?&gt; parameterType, LanguageDriver languageDriver,
      Method method) {
<span class="fc bfc" id="L591" title="All 2 branches covered.">    if (annotation instanceof Select) {</span>
<span class="fc" id="L592">      return buildSqlSourceFromStrings(((Select) annotation).value(), parameterType, languageDriver);</span>
    }
<span class="fc bfc" id="L594" title="All 2 branches covered.">    if (annotation instanceof Update) {</span>
<span class="fc" id="L595">      return buildSqlSourceFromStrings(((Update) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">    } else if (annotation instanceof Insert) {</span>
<span class="fc" id="L597">      return buildSqlSourceFromStrings(((Insert) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">    } else if (annotation instanceof Delete) {</span>
<span class="fc" id="L599">      return buildSqlSourceFromStrings(((Delete) annotation).value(), parameterType, languageDriver);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">    } else if (annotation instanceof SelectKey) {</span>
<span class="fc" id="L601">      return buildSqlSourceFromStrings(((SelectKey) annotation).statement(), parameterType, languageDriver);</span>
    }
<span class="fc" id="L603">    return new ProviderSqlSource(assistant.getConfiguration(), annotation, type, method);</span>
  }

  private SqlSource buildSqlSourceFromStrings(String[] strings, Class&lt;?&gt; parameterTypeClass,
      LanguageDriver languageDriver) {
<span class="fc" id="L608">    return languageDriver.createSqlSource(configuration, String.join(&quot; &quot;, strings).trim(), parameterTypeClass);</span>
  }

  @SafeVarargs
  private final Optional&lt;AnnotationWrapper&gt; getAnnotationWrapper(Method method, boolean errorIfNoMatch,
      Class&lt;? extends Annotation&gt;... targetTypes) {
<span class="fc" id="L614">    return getAnnotationWrapper(method, errorIfNoMatch, Arrays.asList(targetTypes));</span>
  }

  private Optional&lt;AnnotationWrapper&gt; getAnnotationWrapper(Method method, boolean errorIfNoMatch,
      Collection&lt;Class&lt;? extends Annotation&gt;&gt; targetTypes) {
<span class="fc" id="L619">    String databaseId = configuration.getDatabaseId();</span>
<span class="fc" id="L620">    Map&lt;String, AnnotationWrapper&gt; statementAnnotations = targetTypes.stream()</span>
<span class="fc" id="L621">        .flatMap(x -&gt; Arrays.stream(method.getAnnotationsByType(x))).map(AnnotationWrapper::new)</span>
<span class="fc" id="L622">        .collect(Collectors.toMap(AnnotationWrapper::getDatabaseId, x -&gt; x, (existing, duplicate) -&gt; {</span>
<span class="fc" id="L623">          throw new BuilderException(</span>
<span class="fc" id="L624">              String.format(&quot;Detected conflicting annotations '%s' and '%s' on '%s'.&quot;, existing.getAnnotation(),</span>
<span class="fc" id="L625">                  duplicate.getAnnotation(), method.getDeclaringClass().getName() + &quot;.&quot; + method.getName()));</span>
        }));
<span class="fc" id="L627">    AnnotationWrapper annotationWrapper = null;</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">    if (databaseId != null) {</span>
<span class="fc" id="L629">      annotationWrapper = statementAnnotations.get(databaseId);</span>
    }
<span class="fc bfc" id="L631" title="All 2 branches covered.">    if (annotationWrapper == null) {</span>
<span class="fc" id="L632">      annotationWrapper = statementAnnotations.get(&quot;&quot;);</span>
    }
<span class="fc bfc" id="L634" title="All 6 branches covered.">    if (errorIfNoMatch &amp;&amp; annotationWrapper == null &amp;&amp; !statementAnnotations.isEmpty()) {</span>
      // Annotations exist, but there is no matching one for the specified databaseId
<span class="fc" id="L636">      throw new BuilderException(String.format(</span>
          &quot;Could not find a statement annotation that correspond a current database or default statement on method '%s.%s'. Current database id is [%s].&quot;,
<span class="fc" id="L638">          method.getDeclaringClass().getName(), method.getName(), databaseId));</span>
    }
<span class="fc" id="L640">    return Optional.ofNullable(annotationWrapper);</span>
  }

  public static Class&lt;?&gt; getMethodReturnType(String mapperFqn, String localStatementId) {
<span class="pc bpc" id="L644" title="2 of 4 branches missed.">    if (mapperFqn == null || localStatementId == null) {</span>
<span class="nc" id="L645">      return null;</span>
    }
    try {
<span class="fc" id="L648">      Class&lt;?&gt; mapperClass = Resources.classForName(mapperFqn);</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">      for (Method method : mapperClass.getMethods()) {</span>
<span class="pc bpc" id="L650" title="1 of 4 branches missed.">        if (method.getName().equals(localStatementId) &amp;&amp; canHaveStatement(method)) {</span>
<span class="fc" id="L651">          return getReturnType(method, mapperClass);</span>
        }
      }
<span class="fc" id="L654">    } catch (ClassNotFoundException e) {</span>
      // No corresponding mapper interface which is OK
<span class="fc" id="L656">    }</span>
<span class="fc" id="L657">    return null;</span>
  }

  private static class AnnotationWrapper {
    private final Annotation annotation;
    private final String databaseId;
    private final SqlCommandType sqlCommandType;
    private boolean dirtySelect;

<span class="fc" id="L666">    AnnotationWrapper(Annotation annotation) {</span>
<span class="fc" id="L667">      this.annotation = annotation;</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">      if (annotation instanceof Select) {</span>
<span class="fc" id="L669">        databaseId = ((Select) annotation).databaseId();</span>
<span class="fc" id="L670">        sqlCommandType = SqlCommandType.SELECT;</span>
<span class="fc" id="L671">        dirtySelect = ((Select) annotation).affectData();</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">      } else if (annotation instanceof Update) {</span>
<span class="fc" id="L673">        databaseId = ((Update) annotation).databaseId();</span>
<span class="fc" id="L674">        sqlCommandType = SqlCommandType.UPDATE;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">      } else if (annotation instanceof Insert) {</span>
<span class="fc" id="L676">        databaseId = ((Insert) annotation).databaseId();</span>
<span class="fc" id="L677">        sqlCommandType = SqlCommandType.INSERT;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">      } else if (annotation instanceof Delete) {</span>
<span class="fc" id="L679">        databaseId = ((Delete) annotation).databaseId();</span>
<span class="fc" id="L680">        sqlCommandType = SqlCommandType.DELETE;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">      } else if (annotation instanceof SelectProvider) {</span>
<span class="fc" id="L682">        databaseId = ((SelectProvider) annotation).databaseId();</span>
<span class="fc" id="L683">        sqlCommandType = SqlCommandType.SELECT;</span>
<span class="fc" id="L684">        dirtySelect = ((SelectProvider) annotation).affectData();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">      } else if (annotation instanceof UpdateProvider) {</span>
<span class="fc" id="L686">        databaseId = ((UpdateProvider) annotation).databaseId();</span>
<span class="fc" id="L687">        sqlCommandType = SqlCommandType.UPDATE;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">      } else if (annotation instanceof InsertProvider) {</span>
<span class="fc" id="L689">        databaseId = ((InsertProvider) annotation).databaseId();</span>
<span class="fc" id="L690">        sqlCommandType = SqlCommandType.INSERT;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">      } else if (annotation instanceof DeleteProvider) {</span>
<span class="fc" id="L692">        databaseId = ((DeleteProvider) annotation).databaseId();</span>
<span class="fc" id="L693">        sqlCommandType = SqlCommandType.DELETE;</span>
      } else {
<span class="fc" id="L695">        sqlCommandType = SqlCommandType.UNKNOWN;</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">        if (annotation instanceof Options) {</span>
<span class="fc" id="L697">          databaseId = ((Options) annotation).databaseId();</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        } else if (annotation instanceof SelectKey) {</span>
<span class="fc" id="L699">          databaseId = ((SelectKey) annotation).databaseId();</span>
        } else {
<span class="nc" id="L701">          databaseId = &quot;&quot;;</span>
        }
      }
<span class="fc" id="L704">    }</span>

    Annotation getAnnotation() {
<span class="fc" id="L707">      return annotation;</span>
    }

    SqlCommandType getSqlCommandType() {
<span class="fc" id="L711">      return sqlCommandType;</span>
    }

    String getDatabaseId() {
<span class="fc" id="L715">      return databaseId;</span>
    }

    boolean isDirtySelect() {
<span class="fc" id="L719">      return dirtySelect;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>